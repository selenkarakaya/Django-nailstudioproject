#A serializer converts complex data types (like model instances) into JSON format and validates incoming data to create or update database objects.


from django.contrib.auth.models import User
from rest_framework import serializers
from .models import Appt, Feedback
from rest_framework_simplejwt.tokens import RefreshToken


#User Serializer
class UserSerializer(serializers.ModelSerializer):
    """
    Serializer for User model.

    This serializer is used to convert the User model instances into JSON format and vice versa. It handles serialization and deserialization for creating, updating, or retrieving user data.

    Fields:
    -------
    - `id`: The unique identifier of the user (automatically generated by Django).
    - `username`: The username chosen by the user (used for logging in).
    - `email`: The email address associated with the user account.
    - `password`: The password associated with the user. This field is write-only, meaning it will not be included in serialized output, but will be used for creating or updating the password.

    Methods:
    --------
    - `create(validated_data)`: This method is called when creating a new user instance. It accepts validated data, creates a new user using the `create_user` method, and returns the newly created user instance.

    Note:
    -----
    - `extra_kwargs`: This is used to set `password` as `write_only=True`, which means it will not be included in the serialized output (e.g., when fetching data for the user), but it can be used for creating or updating the user.
    """
    class Meta:
        model = User
        fields = ["id", "username", "email", "password"]
        extra_kwargs = {"password": {"write_only": True}}
        
    def create(self, validated_data):
        # Print the validated data (useful for debugging)
        print(validated_data)

        # Create a new user with the validated data, using `create_user` to hash the password
        user = User.objects.create_user(**validated_data)

        # Return the newly created user instance
        return user
    

    
class LoginSerializer(serializers.Serializer):
    """
    Serializer for user login.

    This serializer validates the login credentials (email and password) and provides the necessary
    tokens for authentication if the credentials are valid. It checks if the user exists, if the
    password matches, and if the user is active. Upon successful authentication, it generates an
    access and refresh token.

    Fields:
    -------
    - `email`: The email address used for user login (must be a valid email format).
    - `password`: The password entered by the user (write-only field).

    Methods:
    --------
    - `validate(attrs)`: This method checks if the provided credentials are correct. It retrieves the user
      based on the email, validates the password, and checks if the user is active. If any validation fails,
      it raises a `ValidationError`.
    - `get_token(cls, user)`: This method generates a JWT token for the user, including the user's email in the token payload.

    Returns:
    --------
    - On successful authentication, returns a dictionary containing the `access` token and `refresh` token.
    - Raises `ValidationError` if the credentials are invalid or the user is inactive.
    """
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)

    def validate(self, attrs):
        email = attrs.get("email") # Email field for user login
        password = attrs.get("password")  # Password field, write-only to avoid exposing it

        try:
            # Attempt to retrieve the user by email
            user = User.objects.get(email=email)
        except User.DoesNotExist:
            print(f"No user found with email: {email}")
            raise serializers.ValidationError("Invalid credentials")
        
        # Check if the password matches the stored hashed password
        if not user.check_password(password):
            print(f"Password mismatch for user: {email}")
            raise serializers.ValidationError("Invalid credentials")
        
         # Check if the user is active
        if not user.is_active:
            print(f"User {user.email} is not active")
            raise serializers.ValidationError("Inactive user")
        print(f"User authenticated successfully: {user.email}")

        # Generate a refresh token for the authenticated user
        refresh = RefreshToken.for_user(user)

        # Return access and refresh tokens
        return {
            'access': str(refresh.access_token),
            'refresh': str(refresh),
        }

    def get_token(cls, user):
        # Generate a token for the user and include the user's email in the token payload
        token = super().get_token(user)
        token['email'] = user.email
        return token

#Appointment Serializer
    
class ApptSerializer(serializers.ModelSerializer):
    """
    Serializer for the Appointment (Appt) model.

    This serializer is used to convert `Appt` model instances into JSON format and vice versa.
    It handles serialization and deserialization for appointment data, allowing you to create,
    update, or retrieve appointments via API.

    Fields:
    -------
    - `id`: The unique identifier of the appointment (automatically generated by Django).
    - `service`: The name of the service for the appointment.
    - `message`: Any additional information or message provided by the user regarding the appointment.
    - `appointment_date`: The scheduled date and time for the appointment.
    - `status`: The current status of the appointment (e.g., open, completed, canceled).
    - `created_at`: The timestamp indicating when the appointment was created.
    - `author`: A reference to the user who created the appointment. This is read-only, meaning it cannot be modified by the client.

    Methods:
    --------
    - `Meta`: Specifies the model to be used (`Appt`) and the fields to include in the serialized output.
    - `extra_kwargs`: The `author` field is set to `read_only=True`, ensuring that it cannot be modified or provided by the client during serialization or deserialization.

    Note:
    -----
    The `author` field is set to read-only because the user who created the appointment is automatically
    assigned when the appointment is created, and it should not be updated or changed by the client.
    """
    class Meta:
        model=Appt
        fields=["id", "service", "message",'appointment_date',"status", "created_at", "author"]
        extra_kwargs = {"author": {"read_only": True}}

# Feedback Serializer
class FeedbackSerializer(serializers.ModelSerializer):
    """
    Serializer for the Feedback model.

    This serializer handles the conversion of `Feedback` model instances to and from JSON format.
    It allows users to submit feedback (comment and optional image) and associate it with the user who provided the feedback.

    Fields:
    -------
    - `id`: The unique identifier for the feedback (automatically generated by Django).
    - `user`: The user who submitted the feedback. This is a read-only field and is included only when reading feedback.
    - `comment`: The text feedback provided by the user.
    - `image`: An optional image submitted by the user along with the feedback.
    - `created_at`: The timestamp of when the feedback was created (automatically set by Django).

    Methods:
    --------
    - `create(validated_data)`: This method creates a new feedback record. It checks the authenticated user from the request context and associates the feedback with them. The user is not provided in the incoming data but is automatically added based on the authenticated user.

    Note:
    -----
    - The `user` field is marked as `read_only=True`, meaning it will be included when reading feedback but cannot be modified when creating or updating feedback.
    """
    user = UserSerializer(read_only=True, required=False)  #We retrieve the user only for reading.
    class Meta:
        model = Feedback
        fields = ['id', 'user', 'comment', 'image', 'created_at']
    def create(self, validated_data):
        #While creating the feedback, we verify the user's information and save the feedback.
        user = self.context['request'].user if self.context['request'].user.is_authenticated else None
        # We remove the 'user' data from validated_data because we are sending it separately.
        validated_data.pop('user', None)
        feedback = Feedback.objects.create(user=user, **validated_data)
        return feedback    

       